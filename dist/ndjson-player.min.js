// ------- Functions -------
"use strict";
/**
 * Some utils to work with DOM
 * @Author: A.Lepe <dev@alepe.com>
 */
class Utils {
    static htmlNode(html) {
        const template = Utils.newNode("template");
        template.innerHTML = html.trim();
        return template.content.firstChild;
    };
    static newNode(tagName) {
        return document.createElement(tagName);
    };
    static node(selector, root) {
        if (root === undefined) {
            root = document;
        }
        return selector instanceof Node ? selector : root.querySelector(selector);
    };
    static isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    };
    static isSelectorID(s) {
        return (s + "").trim().indexOf("#") === 0;
    };
    static isPlainObject(o) {
        return Utils.isObject(o) && !Utils.isArray(o);
    };
    static isObject(oa) {
        return typeof oa === 'object';
    };
    static isArray(a) {
        return Array.isArray(a);
    };
    static isFunction(f) {
        return typeof f === 'function';
    };
    static isHtml(s) {
        return (s + "").trim().indexOf("<") !== -1;
    };
    static isEmpty(obj) {
        return obj === undefined || (Utils.isObject(obj) && Object.keys(obj).length === 0) || obj === "";
    };
    static fmtTime(time) {
        time = time.toFixed(1);
        let decimal = time.split(".")[1] || "0";
        return (~~(time / 60) + "").padStart(2, '0') + ":" + (~~((time / 60) % 1 * 60) + "").padStart(2, '0') + "." + decimal;
    }
}

/**
 * @author: A. Lepe
 * @url : https://gitlab.com/lepe/m2d2/
 * @since: May, 2018
 * @version: 1.3.0
 * @updated: 2020-04-20
 *
 * Examples:
 // -- Without "root":
 * const myobj = m2d2("text in body");
 * const myobj = m2d2({ div : { text : "hello" } });
 * const myobj = m2d2([ {},{},{} ]); //Setting list without template and root
 * const myobj = m2d2(function(callback) { ... });
 // -- With "root":
 * const myobj = m2d2("#root", "text in #root");
 * const myobj = m2d2("#input", { value : 199 }); //Using properties
 * const myobj = m2d2("#input", [ 0, 1, 2 ]); //Setting list without template
 * const myobj = m2d2("#clock", function(callback) { ... }); //Using a function (e.g. getting data from another server)
 // -- With template:
 * const myobj = m2d2("#ul", [ 1, 2, 3 ], "li"); //Defining template as 3rd parameter
 * const myobj = m2d2("#ul", [ 1, 2, 3 ], { li : { 'class' : 'blue' } }); //Defining template as object
 * const myobj = m2d2("#clock", function(callback) { ... }, "time"); //Using a function and a template
 * const myobj = m2d2("#clock", function(callback) { ... }, { onclick : ... }); //Using object as template
 */
"use strict";
/**
 * Main class
 */
class M2D2 {
	//------- options ---------------
	root;   // DOM baseline to perform searches and replacements. The outer element.
	//----- Public functions ----------------
	constructor(options) {
		this.root 		= options.root || "body";
		this.template 	= options.template || {};
		this.data 		= options.data || [];
		//Initialize
		this._init();
	}
	// Private static to store extensions
	static _ext  = {};
	// For extensions to use
	static extend(properties) {
		Object.assign(M2D2._ext, properties);
	}
	/**
	 * Update model data
	 */
	update (data, property, valObj) {
		const _this = this;
		if(_this._rendered) {
			const doUpdate = function (data) {
				let node;
				if (data._node !== undefined) {
					if (Utils.isArray(data)) {
						//Item was removed
						if (valObj === undefined) {
							if (data[property]._node !== undefined) {
								// Remove element
								data[property]._node.remove();
							}
						} else {
							let n;
							const toRemove = [];
							for (n in data._node.childNodes) {
								node = data._node.childNodes[n];
								if (node.tagName !== undefined && node.tagName !== "TEMPLATE") {
									toRemove.push(node);
								}
							}
							for (n in toRemove) {
								node = toRemove[n];
								node.remove();
							}
							_this._doRender(data._node, data);
						}
					} else {
						const change = {};
						change[property] = valObj.value;
						_this._doRender(data._node, Object.assign(data, change));
					}
				} else {
					// Clear root element
					_this.clear();
					_this._doRender(_this.$root, data);
				}
			};
			if(property === undefined && Utils.isFunction(_this._func)) {
				_this._doFunc(_this._func, data, function(newData){
					doUpdate(newData);
				});
			} else {
				doUpdate(data);
			}
		}
	}
	/**
	 * Returns data object
	 */
	get () {
		const _this = this;
		_this._defineProp(_this._data, "m2d2", this);
		_this._setProxy();
		return this._data;
	}
	/**
	 * Removes added model items //TODO: move to items? maybe not needed.
	 */
	clear () {
		const _this = this;
		if(_this._rendered) {
			_this.$root.innerHTML = _this._cache;
		}
	}
	//---- Private --
	$root       = null;     // root DOM element e.g. "<body>...</body>"
	_rendered   = false;    // true if the data has been rendered
	_updater 	= true;
	_cache 		= null;
	_data  		= null;
	_func  		= null;
	// HTML5 valid attributes and tags (2018)
	_htmlGenTags = ["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","datalist","dd","del","details","dfn","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","map","mark","menu","meter","nav","ol","optgroup","option","output","p","pre","progress","q","rp","rt","ruby","samp","section","select","small","span","strong","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","tr","tt","ul","var"];
	/**
	 * Initialize data. If its a function, call it.
	 */
	_init () {
		const _this = this;
		if(Utils.isFunction(_this._data)) {
			_this._func = _this._data;
			let syncRet = _this._doFunc(_this._func, _this.param);
			//If the function returns a value, render it
			if(syncRet) {
				//Wrap it if its an array
				if(Utils.isArray(syncRet)) {
					syncRet = { items: syncRet };
				}
				_this._data = syncRet;
				_this._onReady();
			}
		} else {
			// In case its a Number of String, wrap it.
			if(!Utils.isObject(_this._data)) {
				_this._data = { text : _this._data };
			}
			_this._onReady();
		}
	}
	/**
	 * Render data
	 */
	_render () {
		const _this = this;
		if(_this._data === undefined) {
			console.log("data is missing in m2d2 object with root: "+_this.root)
			return false;
		}
		// Render data
		_this._doRender(_this.$root, _this._data);
		// Set trigger on modifications
		_this._rendered = true;
	}
	_onReady () {
		const _this = this;
		_this.$root = Utils.node(_this.root);
		_this._cache = _this.$root.innerHTML; //In order to be able to rollback root.
		_this._render();
	}
	_doFunc (origFunc, param, callback) {
		const _this = this;
		let ret_data = origFunc(function (newData, second, third) {
			let refreshRate;
			if (third !== undefined && Utils.isNumeric(third)) {
				refreshRate = third;
			} else if (second !== undefined && Utils.isNumeric(second)) {
				refreshRate = second;
			}
			if (Utils.isArray(newData)) {
				const wrapper = {};
				if (second !== undefined && !Utils.isNumeric(second)) {
					wrapper.template = second;
				} else if (_this.template !== undefined) {
					wrapper.template = _this.template
				}
				wrapper.items = newData;
				newData = wrapper;
			}
			if (Utils.isPlainObject(newData)) {
				_this._updater = false;
				let idx = 1;
				for (let n in newData) {
					if (idx++ === Object.keys(newData).length) {
						_this._updater = true;
					}
					_this._data[n] = newData[n];
				}
			}
			if (refreshRate === undefined) {
				if (_this.interval > 0) {
					refreshRate = _this.interval;
				}
			}
			if (refreshRate > 0) {
				_this.interval = setInterval(function () {
					_this._func(function (updData) {
						_this._doRender(_this.$root, updData);
					});
				}, refreshRate);
			}
			if (callback !== undefined) {
				callback(newData);
			}
		}, param) || {items: []};
		//Wrap it if its an array:
		if(Utils.isArray(ret_data)) {
			ret_data = { items : ret_data }
		}
		if(!Utils.isObject(ret_data)) {
			console.log("Undefined type of 'data'. For automatic detection do not set any 'return' in the data's function. Or explicitly return '[]' for arrays or '{}' for objects.")
		}
		return ret_data;
	}
	_setProxy () {
		const _this = this;
		if(_this._data._proxy === undefined && (Utils.isPlainObject(_this._data) || Utils.isArray(_this._data))) {
			_this._data = _this._proxy(_this._data, function(obj, variable, value) { //onChange...
				if(variable !== "m2d2" && variable[0] !== '_' && _this._updater) { //Do not update if it starts with '_'
					_this.update(obj, variable, value);
				}
			});
		}
	}
	// Render an element with its values
	_doRender ($elem, value) {
		const _this = this;
		// Initial trigger
		if(value && value.oninit !== undefined && Utils.isFunction(value.oninit)) {
			value.oninit();
			delete(value.oninit);
		}
		_this._setProxy();
		// Arrays : automatic conversion from [] to { items : [] }
		if(Utils.isArray(value)) {
			value = { items : value };
		}
		/*if(isArray(value)) {
            _this._doArray($elem, _this, value);
        }*/
		//Number, String or Objects
		if(value && Utils.isObject(value) && value.items === undefined) {
			value.items = [];
		}
		_this._setValues($elem, value);
		if(value && value.onrender !== undefined && Utils.isFunction(value.onrender)) {
			value.onrender();
			delete(value.onrender); //Run only once
		}
	}
	// Process an array
	_doArray ($elem, obj, values) {
		const _this = this;
		_this._setNode($elem, values);
		let template = _this._getTemplate($elem, obj);
		for(let i = 0; i < (values.length || Object.keys(values).length); i++) {
			const val = values[i] || Object.values(values)[i];
			if(val._node !== undefined) {
				val._node = undefined;
			}
			if(!template) {
				if(Utils.isPlainObject(val)) {
					if(Object.keys(val).length === 1) {
						if(Utils.isSelectorID(val)) {
							const idNode = document.querySelector(val);
							if(idNode) {
								template = idNode.outerHTML;
							} else {
								console.log("Warning: ID selector for template not found: "+val+" . Object:");
								console.log(obj);
								return
							}
						} else {
							template = Utils.newNode(Object.keys(val)[0]).outerHTML;
						}
					} else {
						console.log("Warning: Multiple keys in data without template is not supported yet. Object:");
						console.log(obj);
						return
					}
				} else {
					console.log("Warning: No template found for object:");
					console.log(obj);
					return
				}
			}
			const $item = Utils.htmlNode(template);
			$item.setAttribute("data-id", i);
			$elem.append($item);
			_this._setValues($item, val);
		}
	}
	// Returns a copy of the model to duplicate
	// $elem is to search in DOM for <template>
	// obj is to search for property "template"
	//TODO: template is getting lost from obj.template, and it is getting it from obj._template (which is a cache) but it has no events.
	_getTemplate ($elem, obj) {
		const _this = this;
		if(obj._template !== undefined && obj._template !== "") { //TODO <---here
			return obj._template;
		} else {
			let $template;
			if(obj.template !== undefined) {  //TODO <--- and here
				if(Utils.isPlainObject(obj.template)) {
					$template = Utils.newNode("div");
					_this._setValues($template, obj.template);
				} else if(Utils.isSelectorID(obj.template)) {
					$template = document.querySelector(obj.template);
				} else if(Utils.isHtml(obj.template)) {
					$template = Utils.htmlNode("<template>"+obj.template+"</template>");
				} else {
					$template = Utils.htmlNode("<template>"+Utils.newNode(obj.template).outerHTML+"</template>");
				}
			} else {
				$template = Utils.node("template", $elem);
			}
			// If not template is found, use html as of element
			if($template) {
				const html = $template.innerHTML.trim();
				_this._defineProp(obj, "_template", html);
				return html;
			} else {
				return $elem.innerHTML.trim();
			}
		}
	}
	// Set values in elements
	_setValues ($elem, value) {
		const _this = this;
		// Arrays : automatic conversion from [] to { items : [] }
		if(Utils.isArray(value)) {
			value = { items : value };
		}
		if(Utils.isPlainObject(value)) {
			_this._setNode($elem, value);
			for(let key in value) {
				const item = value[key];
				// Process Array:
				if(key === "items") {
					//TODO: if by this point there is no template detected, warn
					//TODO: alternatively, automatic create template: e.g: ul -> li, select -> option, etc
					_this._doArray($elem, value, item);
				} else if(key === "template") {
					// If it contains a template property, add it as HTML
					$elem.append(Utils.htmlNode("<template>" + _this._getTemplate($elem, value) + "</template>"));
				} else {
					if(key === "items" &&! Utils.isArray(item)) {
						console.log("Warning: 'items' specified but value is not and array in element: ");
						console.log($elem);
						console.log("Passed values are: ");
						console.log(item);
					}
					// Apply extensions:
					if(M2D2._ext[key] !== undefined && Utils.isFunction(M2D2._ext[key])) {
						const ret = M2D2._ext[key](item, $elem);
						if(ret) {
							_this._setValues($elem, ret);
						}
						// ID defined:
					} else if(key[0] === "#") {
						_this._doRender(Utils.node(key), item);
						// Text or Html specified:
					} else if(key === "text" || key === "html") {
						_this._setValue($elem, key, item);
						// Import dataset: Setting dataset : { id : 'custom' } will override the id set automatically in arrays.
					} else if(key === "dataset" && Utils.isPlainObject(item)) {
						for(let d in item) {
							$elem.setAttribute("data-"+d, item[d]);
						}
						// Styles
					} else if(key === "style") {
						if(Utils.isPlainObject(item)) {
							for(const s in item) {
								$elem.style[s] = item[s];
							}
						} else {
							$elem.style = item;
						}
						// Events
					} else if(key.indexOf("on") === 0 && Utils.isFunction(item)) {
						$elem[key] = item;
						// Date / Time:
					} else if(item instanceof Date) {
						_this._setValue($elem, key, item);
						// Attributes: --Do not set ID with a numeric value
					} else if(_this._hasAttr($elem, key) && !(key === "id" && Utils.isNumeric(item))) {
						if(typeof $elem[key] == "boolean") {
							$elem[key] = item;
						} else {
							$elem.setAttribute(key, item);
						}
						// Search child elements:
					} else {
						// Search by tag name first
						let $subelem = Utils.node(key, $elem);
						if(!$subelem) {
							// Search by ID
							$subelem = Utils.node("#"+key, $elem);
							if(!$subelem) {
								// Search by class
								$subelem = Utils.node("."+key, $elem);
							}
							if(!$subelem) {
								// Generate new element:
								if(_this._htmlGenTags.indexOf(key) !== -1) {
									const $newElem = Utils.newNode(key);
									$elem.append($newElem);
									_this._doRender($newElem, item);
									// Set a new attribute:
								} else if(!Utils.isNumeric(key)) {
									$elem.setAttribute(key, item);
								}
								continue;
							}
						}
						_this._doRender($subelem, item);
					}
				}
			}
			//String or Number
		} else {
			_this._setValue($elem, null, value);
		}
	}
	// Set value for a single element (in case of number, string, boolean, etc)
	_setValue ($elem, key, value) {
		const _this = this;
		// If key is null, it means is not specified, so we try to guess what it is
		let html = false;
		if(key == null) {
			if(value === undefined || value == null) {
				console.log("Value was undefined in element :");
				console.log($elem);
			} else if(Utils.isPlainObject(value) && value.text !== undefined) {
				value = value.text;
			} else if(!Utils.isNumeric(value) && Utils.isHtml(value)) {
				html = true;
			}
		} else if(key === "html") {
			html = true;
		}
		if(html) {
			$elem.innerHTML = value;
		} else {
			// As <li> can have "value", it won't be assigned if key is null
			if(key === "value" || (key == null && _this._hasAttr($elem, "value") && ($elem.tagName !== "LI"))) {
				if(_this._hasAttr($elem, "checked")) {
					if(value === true || value === "true" || value === 1) {
						$elem.setAttribute("checked",true);
					} else if(value === false || value === "false" || value === 0) {
						$elem.setAttribute("checked",false);
					} else {
						$elem.value = value;
					}
				} else if(value instanceof Date) {
					$elem.valueAsDate = value;
				} else {
					$elem.value = value;
				}
			} else {
				// If the element has children, only change text
				if($elem.childElementCount > 0) {
					for(let i in $elem.childNodes) {
						const inode = $elem.childNodes[i];
						if(inode.nodeType === 3) {
							inode.replaceWith(value);
							return;
						}
					}
					// If text node not found, append it
					$elem.innerHTML = $elem.innerHTML + value; //TODO: not the best way IMHO
				} else {
					$elem.innerText = value;
				}
			}
		}
	}
	_hasAttr ($node, attr) {
		let hasAttr = false;
		if($node && !Utils.isNumeric(attr)) {
			switch(attr) {
				case "checked":
					hasAttr = ($node.type !== undefined && ($node.type === "radio" || $node.type === "checkbox"));
					break;
				default:
					hasAttr = $node[attr] !== undefined || $node.hasAttribute(attr);
			}
		}
		return hasAttr;
	}
	_defineProp (obj, prop, def) {
		if(Utils.isObject(obj)) {
			if(obj[prop] === undefined) {
				Object.defineProperty(obj, prop, {
					enumerable: false,
					writable: true
				});
				obj[prop] = def;
			}
		}
	}
	_setNode ($node, obj) {
		this._defineProp(obj, "_node", $node);
	}
	_proxy (obj, onChange) {
		this._defineProp(obj, "_proxy", true);
		const handler = {
			get: function (target, property, receiver) {
				if (property === "m2d2" || property[0] === '_') {
					return target[property];
				} else {
					const realValue = Reflect.get(target, property, receiver);
					const ownDesc = Object.getOwnPropertyDescriptor(target, property);
					if (ownDesc && !ownDesc.writable && !ownDesc.configurable) {
						return realValue;
					}
					try {
						if (Utils.isArray(obj) && !Utils.isNumeric(property)) {
							return target[property];
						} else {
							return new Proxy(target[property], handler);
						}
					} catch (err) {
						return realValue;
					}
				}
			},
			defineProperty: function (target, property, descriptor) {
				onChange(target, property, descriptor);
				return Reflect.defineProperty(target, property, descriptor);
			},
			deleteProperty: function (target, property) {
				onChange(target, property);
				return Reflect.deleteProperty(target, property);
			},
			set: function (target, property, value) {
				target[property] = value;
				onChange(target, property, {value: value});
				return true;
			}
		};
		return new Proxy(obj, handler);
	}
	//----- setters and getters for data
	set data(value) {
		const _this = this;
		_this._data = value;
		_this.update(_this._data);
	}
	get data() {
		const _this = this;
		return _this._data;
	}
}

/**
 * Main function that will initialize M2D2 class object
 * @param first node to use as root, data, template or function
 * @param second data, template or function
 * @param third data, template or function
 * @returns M2D2 object
 */
const m2d2 = function(first, second, third) {
	const options = {};
	const first_type = typeof first;
	switch (first_type) {
		case "string" :
			if (second !== undefined) {
				options.root = first;
				if (Utils.isArray(second)) {
					second = {items: second};
				}
				options.data = second;
				options.template = third;
			} else { //This is the simple use case : m2d2("Content"); in which "Content" will be set in "body";
				options.data = first;
				return null;
			}
			break;
		// In case the first argument is not a string, root will become the default value.
		case "object" :
			if (first instanceof Node) {
				options.root = first;
				first = second;
			}
		//No break here
		case "function" :
			if (Utils.isArray(first)) {
				second = {items: first};
			}
			options.data = first;
			options.template = third; //it might be undefined
			break;
		default :
			console.log("First argument passed to m2d2, with value: (" + first + ") is of unknown type: " + first_type);
			return null;
	}
	return new M2D2(options).get();
};

/**
 * @author: A. Lepe
 * @url : https://gitlab.com/lepe/m2d2/
 * @since: May, 2018
 *
 * This is an extension to use the property "show" to hide/show elements
 * It will keep previous "display" property value and restore it upon "show".
 * If there is not "previous" display property will search for "data-display"
 * attribute or will set the default for the specified element tag.
 */
M2D2.extend({
	show : function(show, node) {
		const cssDisplay = function () {
			return getComputedStyle(node, null).display;
		};
		const defaultDisplay = function () {
			const b = document.getElementsByTagName("body")[0];
			const t = document.createElement("template");
			const n = document.createElement(node.tagName);
			t.appendChild(n);
			b.appendChild(t);
			const display = getComputedStyle(n, null).display;
			t.remove();
			return display;
		};
		if(show) {
			if(cssDisplay() === "none") {
				if(node.dataset._m2d2_display) {
					node.style.display = node.dataset._m2d2_display;
				} else {
					node.style.removeProperty("display");
					if(cssDisplay() === "none") {
						const defaultShow = defaultDisplay();
						node.style.display = node.dataset.display || (defaultShow !== "none" ? defaultShow : "block");
					}
				}
			}
		} else {
			const stored = node.style.display !== "none" ? node.style.display : cssDisplay();
			if(stored !== "none") {
				node.dataset._m2d2_display = stored;
			}
			node.style.display = "none"
		}
	}
});

/**
 * @author: A. Lepe
 * @url : https://gitlab.com/lepe/m2d2/
 * @since: May, 2018
 *
 * This is an extension to use propertes to set style in elements
 */
M2D2.extend({
	// Set css "color" for text. It accepts any supported CSS value
	color   : function(value, elem) { elem.style.color = value; },
	// Set css "background-color".
	bgcolor : function(value, elem) { elem.style.backgroundColor = value; },
	// Set className. It will replace all classes
	css	    : function(value)       { return { 'class' : value }; },
	// Remove specific class from element
	"-css"  : function(value, elem) {
		let styles = Utils.isArray(value) ? value : value.split(" ");
		for(let s in styles) { elem.classList.remove(styles[s]) };
	},
	// Add class to element
	"+css"  : function(value, elem) {
		let styles = Utils.isArray(value) ? value : value.split(" ");
		for(let s in styles) { elem.classList.add(styles[s]) };
	}
});
/*
  This player uses NDJSON files to play in sequence as a video
  Additionally, it may contain information about the frame
  Inspired in https://github.com/lepe/frame-player/ (by Vagner Santana)

  @Since 2020-04-19
 */
class NdJsonPlayer {
    // Options
    fps;        //default: 24FPS
    loop;       //default: false
    showfirst;  //default: true : show first image
    autoplay;   //default: false
    path;       //default: "" : Specify common path for images in case URL is used.
                //              For example: path = "http://localhost:8080/images/"
                //              then, use "img12334.jpg" as frame in NDJSON (to reduce size of file)

    // Events
    onRender;   // Callback to return metadata when a frame is rendered
    onFinish;   // Callback when video reaches the last frame
    onError;    // Callback when there is an error with the source

    // Private
    #player = null;     // DOM element which contains the <canvas> node
    #canvas = null;     // <canvas> DOM object
    #ctx = null;        // canvas.ctx object
    #timer = null;      // Timer used to manage FPS
    #src = "";          // Video source URI (NDJSON)
    #numFrames = 0;     // Number of total frames (in header)
    #frames = [];       // Video content including metadata (array)
    #frame = 0;         // Current frame being played
    #frameBase = ""     // Base for all frames 'fb'
    #loaded  = false;   // If a frame has been loaded or not
    #playing = false;   // Status
    #backwards = false; // If playing backwards
    #multiplier = 1;    // Multiplier to control speed

    /**
     * Examples:
     * new NdJsonPlayer("/videos/test.ndjson","canvas", { loop: true })
     * new NdJsonPlayer("/videos/test.ndjson", { loop: true })
     * new NdJsonPlayer("/videos/test.ndjson")
     *
     * @param src     .ndjson file (see format)
     * @param element HTML element (must be a canvas). If not set, it will use '<canvas>'
     * @param options Object replacing default values
     * @param onrender Callback when a frame is updated
     * @param onfinish Callback when the video is finished
     * @param onerror Callback when there is an error to raise
     */
    constructor(src, element, options, onrender, onfinish, onerror) {
        const _this = this;
        _this.#src = src;
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
        }
        // Add events:
        _this.onRender   = onrender || function () {}
        _this.onFinish   = onfinish || function () {}
        _this.onError    = onerror  || function (e) { console.log(e); }
        // Fix and check arguments
        if (typeof element == "object") {
            options = element;
            element = "canvas";
        } else if (typeof element != "string") {
            throw "Incorrect parameter passed to constructor of NdJsonPlayer";
        }
        // Look for canvas
        let player = document.querySelector(element || "canvas");
        if (player) {
            if (player.tagName === "CANVAS") {
                _this.#canvas = player;
                // create wrapper container
                const wrapper = document.createElement('div');
                player.parentNode.insertBefore(wrapper, player);
                wrapper.prepend(player);
                player = wrapper;
            } else {
                _this.#canvas = document.createElement("CANVAS");
                player.prepend(_this.#canvas);
            }
        } else {
            throw "Canvas element was not found in DOM: " + element;
        }
        _this.#player = player;
        // Set classname for style
        player.classList.add("ndjp");

        // Set context
        _this.#ctx = _this.#canvas.getContext("2d");

        // Options:
        _this.fps        = options.fps || 24;
        _this.loop       = options.loop || false;
        _this.autoplay   = options.autoplay || false;
        _this.showfirst  = options.showfirst !== false;
        _this.path       = options.path || "";

        // Initialize timer:
        _this.#timer = new Timer(1000 / _this.fps);

        // Load video:
        _this.load(function (item) {
            if(item.fb !== undefined) {
                _this.#frameBase = item.fb;
            }
            if(item.tf !== undefined) {
                _this.#numFrames = item.tf;
            }
            if(item.fps !== undefined) {
                _this.fps= item.fps;
                _this.#timer = new Timer(1000 / _this.fps);
            }
            if(item.f !== undefined) {
                _this.#frames.push(item);
                // AutoPlay:
                if (!_this.#loaded) {
                    _this.#loaded = true;
                    if (_this.autoplay) {
                        _this.play();
                    } else if (_this.showfirst) {
                        _this.step();
                    }
                }
            }
        });
    }

    /**
     * Load a video file or change current video file.
     * @param callback when each frame is ready
     * @param newSrc optional (if not set will read "src" passed in constructor)
     */
    load(callback, newSrc) {
        const _this = this;
        if(newSrc !== undefined) {
            this.#src = newSrc;
            this.#frames = [];
        }
        const decoder = new TextDecoder();
        let buffer = '';
        return fetch(_this.#src)
            .then(resp => resp.body.getReader())
            .then(reader => reader.read()
                .then(function process ({ value, done }) {
                    if (done) {
                        callback(JSON.parse(buffer));
                        return;
                    }
                    const lines = (
                        buffer + decoder.decode(value, { stream: true })
                    ).split(/[\r\n](?=.)/);
                    buffer = lines.pop();
                    lines.map(JSON.parse).forEach(callback);
                return reader.read().then(process);
            })).catch(reason => this.onError(reason));
    }

    /**
     * Render video
     * @param once single step
     */
    _render(once) {
        if (this.#timer == null) {
            throw "Timer was not initialized";
        }
        if(this.#frames.length === 0) {
            throw "Video is empty or no frames were found";
        }

        if(this.#frame >= this.#frames.length) {
            this.#frame = this.loop ? 0 : this.#frames.length;
        }
        if(this.#frame < 0) {
            this.#frame = this.loop ? this.#frames.length - 1: 0;
        }
        this._displayImg(once);
    }

    /**
     * Display next image
     * @param once single step
     */
    _displayImg(once) {
        const _this = this;
        const item = _this.#frames[_this.#frame];
        _this.onRender(item);
        const next = function() {
            _this.#timer.call(function () {
                if (!once) {
                    _this._increment();
                    //Do not execute anything until its loaded
                    _this.#timer.nocall();
                }
                _this._displayImg();
            });
        }
        if(item.f !== undefined) {
            const frame = _this.#frameBase + item.f;
            _this._image(frame, next);
        } else {
            next();
        }
    }

    /**
     * Increment frame
     */
    _increment() {
        this.#frame += (this.#multiplier * (this.#backwards ? -1 : 1));
        if(this.#frame < 0) {
            if(this.loop) {
                this.#frame = this.#frames.length - 1;
            } else {
                this.#frame = 0;
                this.pause();
            }
        }
        if(this.#frame > this.#frames.length - 1) {
            if(this.loop) {
                this.#frame = 0;
            } else {
                this.#frame = this.#frames.length - 1;
                this.pause();
            }
        }
    }

    /**
     * Draws an image object
     * @param img
     * @param callback sends "true" on success
     * @return this
     */
    _draw = function(img, callback) {
        const _this = this;
        /// set size proportional to image
        if(img.width === 0 && img.height === 0) {
            img.onerror();
            if(callback !== undefined) {
                callback(false);
            }
        } else {
            _this.#ctx.save();
            _this.#ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, _this.#canvas.width, _this.#canvas.height);
            _this.#ctx.restore();
            if(callback !== undefined) {
                callback(true);
            }
        }
        return this;
    }
    /**
     * Load an image into canvas.
     * @param image path or url of image
     * @param callback returns img object
     * @return this
     */
    _image = function(image, callback) {
        const _this = this;
        const img = new Image();
        img.crossOrigin = '';
        img.onload = function(){
            _this._draw(img,function(drawn){
                if(drawn) {
                    if(callback !== undefined) {
                        callback(img);
                    }
                }
            });
        };
        img.onerror = function() {
            const err = _this.onError();
            if(err) {
                img.src = err;
            }
        };
        img.src = image[0] === "/" || image.match(/^https?:/) || image.match(/^data:image/) ? image : _this.path + image;
        return this;
    }

    /**
     * Get frame base
     */
    frameBase() {
        return this.#frameBase;
    }
    /**
     * Expose information about the current frame
     * @returns {number}
     * @private
     */
    currentFrame() {
        return this.#frame;
    }

    /**
     * Return number of frames
     * @returns {number}
     * @private
     */
    totalFrames() {
        return this.#numFrames || this.#frames.length;
    }

    /**
     * Return a frame in position
     * @param position
     */
    frameAt(position) {
        const _this = this;
        position =  ~~((position * _this.totalFrames()) / 100);
        let frame = (position < this.totalFrames()) ? _this.#frames[position] : null;
        if(frame) {
            frame.fb = _this.#frameBase;
        }
        return frame;
    }

    /**
     * Return player Node
     * @returns DOM node
     * @private
     */
    playerNode() {
        return this.#player;
    }

    /**
     * Play video in current direction
     * @param startFrame
     */
    play(startFrame) {
        if (startFrame < 0) {
            startFrame = 0;
        } else if (startFrame > this.#frames.length) {
            startFrame = this.#frames.length - 1;
        } else if (startFrame !== undefined) {
            this.#frame = startFrame * 1;
        }
        this.#playing = true;
        this.#timer.play();
        this._render(false);
    }

    /**
     * Play video in forward direction
     * (used mainly to change direction)
     * @param startFrame
     */
    playForward(startFrame) {
        this.#backwards = false;
        this.play(startFrame);
    }

    /**
     * Play video in backwards direction
     * @param startFrame
     */
    playBackwards(startFrame) {
        this.#backwards = true;
        this.play(startFrame);
    }

    /**
     * Pause the video
     */
    pause() {
        this.#playing = false;
        this.#timer.pause();
    }

    /**
     * Stop the video (and go back to the beginning)
     */
    stop() {
        this.#playing = false;
        this.#frame = 0;
        this.#timer.pause();
        this._displayImg(true);
    }

    /**
     * Move the video one frame in the current direction
     */
    step() {
        this._render(true);
    }

    /**
     * Move one frame forwards (and change direction)
     */
    stepForwards() {
        this.#backwards = false;
        this.step()
    }

    /**
     * Move one frame backwards (and change direction)
     */
    stepBackwards() {
        this.#backwards = true;
        this.step()
    }

    /**
     * Reset this object
     * @returns {NdJsonPlayer}
     */
    reset() {
        if (this.#ctx.reset !== undefined) {
            this.#ctx.reset();
            this.#ctx.clear();
            this.stop();
            //Reset all: The following line is a "hack" to force it to reset:
            this.#canvas.width = this.#canvas.width;
        }
        return this;
    }
}

/**
 * This class creates the player UI
 */
class NDJPlayer extends NdJsonPlayer {
    #skin;      //Skin to use
    #options;   //Options for the UI
    #ui;        //The UI

    constructor(src, element, options, onrender) {
        super(src, element, options, function (frame) {
            _this._onUpdate(frame);
            if (onrender !== undefined) {
                onrender(frame);
            }
        }, function () {
            _this.stop()
        }, function (e) {
            //Display error in player
        });
        const _this = this;
        this.#skin = options.skin || "default";
        this.#options = Object.assign({
            play: !_this.autoplay,
            stop: true,
            pause: true, //_this.autoplay,
            step: true,
            progress: true,
            thumbs: true,
            fullscreen: false,
            speed: false,
            lapse: true,
            frames: true
        }, options.ui || {});

        // Create UI
        this._create();
    }

    /**
     * Update the UI
     * @private
     */
    _onUpdate(frame) {
        const _this = this;
        _this.#ui.frames.text = _this.currentFrame() + "/" + _this.totalFrames()
        _this.#ui.lapse.text = Utils.fmtTime(this.currentFrame() / _this.fps);
        _this.#ui.progress.value = (_this.currentFrame() / (_this.totalFrames())) * 100;
    }

    /**
     * Creates the UI
     * @private
     */
    _create() {
        const _this = this;
        _this.#ui = m2d2(_this.playerNode(), {
            '+css': _this.#skin,
            /*template : '<a class="play"></a>\n' +
                '<a class="pause"></a>\n' +
                '<a class="stop"></a>\n' +
                '<label class="lapse"></label>\n' +
                '<label class="frames"></label>\n' +
                '<progress></progress>',*/
            play: {
                '+css': ["fa", "fa-play"],
                show: _this.#options.play,
                title: "Play",
                text: "▶️",
                href: "#",
                onclick: function () {
                    _this.play();
                    return false;
                }
            },
            pause: {
                '+css': ["fa", "fa-pause"],
                show: _this.#options.pause,
                title: "Pause",
                text: "⏸️",
                href: "#",
                onclick: function () {
                    _this.pause();
                    return false;
                }
            },
            stop: {
                '+css': ["fa", "fa-stop"],
                show: _this.#options.stop,
                title: "Stop",
                text: "⏹️",
                href: "#",
                onclick: function () {
                    _this.stop();
                    return false;
                }
            },
            lapse: {
                show: _this.#options.lapse,
                title: "Time elapsed / Time Total",
                text: "0:00 / 0:00"
            },
            frames: {
                show: _this.#options.frames,
                title: "Current Frame / Total Frames",
                text: "0 / 0"
            },
            progress: {
                show: _this.#options.progress,
                value: 0,
                max: 100,
                onmousemove: function (e) {
                    let position = ~~(((e.pageX - this.offsetLeft) / this.clientWidth) * 100);
                    let frame = _this.frameAt(position);
                    if(frame) {
                        _this.#ui.img = {
                            src : _this.frameBase() + frame.th,
                            /*style : {
                                top :
                                left:
                            }*/
                        }
                        let img = _this.#ui.img._node;
                        img.style.left = (e.pageX - (img.width / 2)) + "px"
                        img.style.top = (e.pageY - img.height - 15) + "px"
                    }
                }
            },
            img : {
                src : ""
            }
        });
    }
}
/**
 * @author: A. Lepe
 * Manage Timers
 * Usage:
 * var t = new Timer(1000);
 * t.call(function() { <do> });
 * or:
 * var t = new Timer(1000,function(){ <do> });
 * t.pause();
 * t.destroy();
 */
function Timer(original_ms, callback) {
	let startTime, timer, obj = {}, action, ms;
	obj.interval = original_ms; //Public. Can be updated
	obj.checker = 50; // adjust this number to affect granularity
	obj.status = "init";
	let nowTime = new Date().getTime();
	startTime = nowTime - original_ms; //start right away
	obj.call = function(func) {
		callback = func;
		return obj;
	};
	obj.nocall = function() {
		callback = null;
		return obj;
	};
	//Execute the callback manually and reset the timer
	obj.exec = function() {
		if(callback) callback();
		startTime = new Date().getTime();
		return obj;
	};
	// Checks the status of the timer
	obj.check = function() {
		if(action) action();
		return obj;
	};
    obj.play = function() {
		action = obj.step;
		obj.status = "running";
		return obj;
    };
    obj.pause = function() {
		action = null;
		obj.status = "paused";
		return obj;
    };
	obj.destroy = function() {
		action = null;
        clearInterval(timer);
		timer = null;
		for(var o in obj) {
			obj[o] = null;
			delete obj[o];
		}
		obj.status = "destroyed";
	};
    obj.step = function() {
		nowTime = new Date().getTime();
        ms = Math.max(0, obj.interval - (nowTime - startTime));
        if(ms === 0) {
			ms = obj.interval;
			startTime = new Date().getTime();
			if(callback) callback();
        }
        return obj;
    };
	obj.slow = function() {
		obj.interval = 1000;
		return obj;
	};
	obj.fast = function() {
		obj.interval = original_ms;
		return obj;
	};
    timer = setInterval(obj.check, obj.checker);
    return obj;
}
